!function(t){"function"==typeof define&&define.amd?define(t):t()}((function(){"use strict";class t{static{this.HEADER_SIZE=2*Int32Array.BYTES_PER_ELEMENT}static create(e,s){const i=new SharedArrayBuffer(t.HEADER_SIZE+e*s*Float32Array.BYTES_PER_ELEMENT),r=new t(i,e,s);return Atomics.store(r._ptrs,0,0),Atomics.store(r._ptrs,1,0),r}static attach(e,s,i){return new t(e,s,i)}constructor(e,s,i){this.sab=e,this.frameCapacity=s,this.channelCount=i,this._ptrs=new Int32Array(e,0,2),this._buffer=new Float32Array(e,t.HEADER_SIZE,s*i)}get readIndex(){return Atomics.load(this._ptrs,0)}set readIndex(t){Atomics.store(this._ptrs,0,t)}get writeIndex(){return Atomics.load(this._ptrs,1)}set writeIndex(t){Atomics.store(this._ptrs,1,t)}get sharedArrayBuffer(){return this.sab}availableRead(){return(this.writeIndex-this.readIndex+this.frameCapacity)%this.frameCapacity}availableWrite(){return this.frameCapacity-this.availableRead()-1}write(t){const e=Math.floor(t.length/this.channelCount);let s=this.writeIndex;for(let i=0;i<e;i++){for(let e=0;e<this.channelCount;e++)this._buffer[(s*this.channelCount+e)%this._buffer.length]=t[i*this.channelCount+e];s=(s+1)%this.frameCapacity}this.writeIndex=s}read(t){const e=this.availableRead(),s=Math.min(t,e),i=new Float32Array(s*this.channelCount);let r=this.readIndex;for(let t=0;t<s;t++){for(let e=0;e<this.channelCount;e++)i[t*this.channelCount+e]=this._buffer[(r*this.channelCount+e)%this._buffer.length];r=(r+1)%this.frameCapacity}return this.readIndex=r,i}}class e extends AudioProcessor{constructor(e,s){super(e,s),this.bufferSize=11025,this.buffer=new Float32Array(this.bufferSize),this.writePos=0,this.readPos=0,this.pitchRatio=1.5,this.formantRatio=1.2,this.dryWet=.7,this.hpf={prevIn:0,prevOut:0,alpha:.86},this.mode=0,this.channels=2,this.frameBuffer=[],this.batchSize=4096,this.rb=null,this.frameCapacity=0,this.port.onmessage=e=>{const{command:s,data:i}=e.data;if("init-processor"===s)this.mode=i.mode||0;else if("update-pitch-shift-config"===s){const{pitchRatio:t=1.5,formantRatio:e=1.2,dryWet:s=0}=i;this.pitchRatio=t,this.formantRatio=e,this.dryWet=s}else"attach-ring-buffer"===s&&(this.frameCapacity=i.frameCapacity||0,this.channels=i.channelCount||2,this.rb=t.attach(i.sab,this.frameCapacity,this.channels))}}process(t,e){const s=t[0],i=e[0];if(0===s.length||!s[0])return!0;const r=s[0],h=i[0];for(let t=0;t<r.length;t++)this.buffer[this.writePos]=r[t],this.writePos=(this.writePos+1)%this.bufferSize;for(let t=0;t<h.length;t++){let e=this.readPos%this.bufferSize;e<0&&(e+=this.bufferSize);const s=Math.floor(e),i=e-s,r=(s+1)%this.bufferSize,a=this.buffer[s]*(1-i)+this.buffer[r]*i,n=a-this.hpf.prevIn+this.hpf.alpha*this.hpf.prevOut;this.hpf.prevIn=a,this.hpf.prevOut=n,h[t]=n*this.dryWet+a*(1-this.dryWet),this.readPos+=this.pitchRatio,this.readPos>=this.bufferSize&&(this.readPos-=this.bufferSize,this.writePos=0)}const a=h.length;if(1===this.mode){const t=new Float32Array(a*this.channels);for(let s=0;s<a;s++)for(let i=0;i<this.channels;i++){const r=e[0][i]||e[0][0];t[s*this.channels+i]=r[s]}this.rb?.write(t)}else for(let t=0;t<a;t++){for(let s=0;s<this.channels;s++){const i=e[0][s]||e[0][0];this.frameBuffer.push(i[t])}if(this.frameBuffer.length>=this.batchSize*this.channels){const t=new Float32Array(this.frameBuffer).buffer;this.port.postMessage({command:"preview",data:t},[t]),this.frameBuffer=[]}}return!0}}registerProcessor("pitch-shift-processor",e)}));
